# 2 排序

## 2.1 初级排序算法
### 2.1.1 游戏规则
排序算法模板类，展示了数组排序的框架，我们学的每种排序算法，都会为这个类实现一个sort方法，并将Example类改名称。
```
class Example:
    def __init__(self, elems):
        self.elems = list(elems)
        
    def sort(self):
        pass
    
    def less(self, v, w):
        return v < w
    
    def exchange(self, i, j):
        self.elems[i], self.elems[j] = self.elems[j], self.elems[i]
        
    def show(self):
        return str(self.elems)
        
    def is_sorted(self):
        for i in range(len(self.elems)-1):
            if not self.less(self.elems[i], self.elems[i+1]):
                return False
        return True
```
#### 额外的内存使用
排序算法额外的内存开销也很重要。排序算法可以分为两类：除了函数调用需要的栈和固定数目的实例变量外，无序额外内存的算法，称为原地排序算法；需要额外空间存储数组副本的称为其他排序算法。
#### 数据类型
被排序的数据类型都是可以比较的数据类型，需要实现比较算法。（java中的compareTo），比较算法是完整的比较序列：
* 自反性：对于v，有v=v
* 反对称性：v<w,则有w>v，且v=w,w=v
* 传递性：v,w,x如果v<=w, w<=x,则v<=x

### 2.1.2 选择排序
选择排序：首先，找到数组中最小的元素，将它和数组中第一个元素交换位置，如果第一个元素就是最小的，则跟自己交换。然后再剩下的元素中找到最小的元素，然后跟第二个元素交换位置。如此往复知道整个数组排序。这种排序算法就是选择排序，因为每次都选择数组中最小的元素。

选择排序要n次交换，n(n-1)/2~n^2/2次比较。

特点：
* 运行时间与输入无关。一次扫描不能为下一次扫描提供信息。有序的数组和随机数组排序时间一样长。其他算法善于利用输入的初始状态。
* 数据移动最少，n个元素移动n次，交换次数与数组大小是线性关系。其他算法大部分是线性对数或者平方级别。
```
class SelectionSort(Example):
    def sort(self):
        for i in range(len(self.elems)):
            index = i
            for j in range(i+1, len(self.elems)):
                if self.less(self.elems[j], self.elems[index]):                   
                    index = j
            self.exchange(i, index)
```
