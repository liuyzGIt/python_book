# 排序与搜索
## 目标
* 了解和实现顺序搜索和二分法搜索
* 了解和实现选择排序、冒泡排序、归并排序、快速排序、插入排序、希尔排序、（堆排序）
* 了解散列法实现搜索技术
* 了解抽象数据类型Map
* 采用散列实现抽象数据类型Map

## 1、搜索
在一些项的集合中找到特定项。

python中使用 in 运算符。

### 1.1、顺序搜索
* 一次对比每一个数据项，时间复杂度是O(n)
* 如果列表有序，可以根据被比较数据的大小判断是否继续向后搜索。

### 1.2、二分搜索
* 从中间开始查找，如果中间数据大，则向右查找，如果中间数据小，则向左查找。
* 时间复杂度是O(logn)
* 二分查找是分治法的应用。缩小问题规模，然后重组整个问题，得到最终结果。
* 通过递归方式实现，使用了切片，切片的时间复杂度是O(k),增加了时间。
* 对于较小的n值，排序的附加消耗是不值得的。如果排序一次搜索多次，那排序的开销可以不计。但是对于大列表，一次排序的消耗也非常巨大。因此，一开始使用简单搜索也许是最好的选择。
```
def binary_search(alist, item):
    """二分查找"""
    front = 0
    rear = len(alist) - 1    
    found = False

    while front <= rear and not found:
            mid = (rear + front) // 2
            if alist[mid] > item:
                rear = mid - 1
            elif alist[mid] < item:
                front = mid + 1
            else:
                found = True
    return found    
print(binary_search([0,1,2,3,4,5,6,7,8,9,10], 100))


def binary_search_recursion(alist, item):
    """二分查找的递归版本"""
    if len(alist) == 0:
        return False
    else:
        # 在list中,len(list)//2 下标一定落在数组中
        # (len(alist)-1) // 2 不影响最终结果
        mid = len(alist) // 2
        if alist[mid] == item:
            return True
        elif alist[mid] > item:
            return binary_search_recursion(alist[:mid], item)
        elif alist[mid] < item:
            return binary_search_recursion(alist[mid+1:], item)

print(i, binary_search([0,1,2,3,4,5,6,7,8,9,10], i))

  
def binary_search_recursion_without_slice(alist, start, end, item):
    """递归不使用切片"""
    if start > end:
        return False
    else:
        mid = (start + end) // 2
        if alist[mid] == item:
            return True
        elif alist[mid] > item:
            return binary_search_recursion_without_slice(alist, start, mid-1, item)
        elif alist[mid] < item:
            return binary_search_recursion_without_slice(alist, mid+1, end, item)

alist = [0,1,2,3,4,5,6,7,8,9,10,100]
for i in alist:    
    print(i, binary_search_recursion_without_slice(alist,0,len(alist)-1, i))
    
print(binary_search_recursion_without_slice(alist,0,len(alist)-1, 200))
```

### 1.3、散列
散列表是一种数据集合，它的每个数据都通过某种特定的方式进行存储，以方便后期查找，散列表的每一个位置称为槽，存储一个数据项，并从0开始递增命名。  


